{"name":"Id","tagline":"Simple models based on hashes","body":"# id\r\n### simple models based on hashes\r\n\r\nJSON is a great way to transfer data between systems, and it's easy to parse into a Ruby hash. But sometimes it's nice to have actual methods to call when you want to get attributes from your data, rather than coupling your entire codebase to the hash representation by littering it with calls to `fetch` or `[]`. The same goes for BSON documents stored in Mongo.\r\n\r\nThat's where `id` (as in Freud) comes in. You define your model classes using syntax that should look pretty familiar if you've used any popular Ruby ORMs - but `id` is not an ORM. Model objects defined with `id` have a constructor that accepts a hash, and you define the values of this hash that are made readable as fields - but that hash can come from any source.\r\n\r\n#### Defining a model\r\n\r\nDefining a model looks like this:\r\n\r\n    class MyModel\r\n      include Id::Model\r\n\r\n      field :foo\r\n      field :bar, default: 42\r\n      field :baz, key: 'barry'\r\n\r\n    end\r\n\r\n    my_model = MyModel.new(foo: 7, barry: 'hello')\r\n    my_model.foo # => 7\r\n    my_model.bar # => 42\r\n    my_model.baz # => 'hello'\r\n\r\nAs you can see, you can specify default values as well as key aliases.\r\n\r\n#### Associations\r\n\r\nYou can also specify has_one or has_many \"associations\" - what would be nested subdocuments in MongoDB for example - like this:\r\n\r\n    class Zoo\r\n      include Id::Model\r\n\r\n      has_many :lions\r\n      has_many :zebras\r\n      has_one :zookeeper, type: Person\r\n    end\r\n\r\n    zoo = Zoo.new(lions: [{name: 'Hetty'}],\r\n                  zebras: [{name: 'Lisa'}],\r\n                  zookeeper: {name: 'Russell' d})\r\n\r\n    zoo.lions.first.class # => Lion\r\n    zoo.lions.first.name  # => \"Hetty\"\r\n    zoo.zookeeper.class   # => Person\r\n    zoo.zookeeper.name    # => \"Russell\"\r\n\r\nTypes are inferred from the association name unless one is specified.\r\n\r\n#### Designed for immutability\r\n\r\n`id` models provide accessor methods, but no mutator methods, because they are designed for immutability. How do immutable models work? When you need to change some field of a model object, a new copy of the object is created with the field changed as required. This is handled for you by `id`'s `set` method:\r\n\r\n    person = Person.new(name: 'Russell', job: 'programmer')\r\n    person.set(name: 'Radek') # => returns a new Person whose name is Radek and whose job is 'programmer'\r\n\r\nYou can even set fields on nested models in this way:\r\n\r\n    person.hat.set(color: 'red') # => returns a new person object with a new hat object with its color set to red\r\n\r\n#### Avoiding nils\r\n\r\n`id` tries to avoid nils entirely, by using the Option pattern found in many functional programming languages and implemented [here](http://github.com/rsslldnphy/optional).\r\nJust mark optional fields as `optional: true` and their accessors will return either `Some[value]` or `None`.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}